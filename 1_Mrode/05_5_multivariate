####################################################################################
#                                                                                  #
#                  Multivariate Example 5.5, pages 102 - 105                       #
#                                                                                  #
####################################################################################
mkdir Multivar_anim_5_5
cd Multivar_anim_5_5

# generate pedigree file
echo "anim sire dam" > ped_head
cat <<EOF > pedigree
1 . .
2 . .
3 . .
4 1 2
5 3 2
6 1 5
7 3 4
8 1 7
EOF

# generate performance file
echo "anim HYS1 HYS2 FAT1 FAT2" > perf_head
cat <<EOF > perf
4 1 1 201 280
5 1 2 150 200
6 2 1 160 190
7 1 1 180 250
8 2 2 285 300
EOF

# generate genetic variance file
cat <<EOF > G0
35 28
28 30
EOF

# generate residual variance file
cat <<EOF > R0
65 27
27 70
EOF

invert -i G0 -o G0inv
export g11=$(mprint -p G0inv|  awk 'NR==1{print $1}')
export g12=$(mprint -p G0inv|  awk 'NR==1{print $2}')
export g22=$(mprint -p G0inv|  awk 'NR==2{print $2}')

# stack pedigree
stack_ped pedigree ped_stk

# generate Ainverse and calculate inbreeding
invnrm -i ped_stk -a -o inbreed -v Ainv

# vectors to generate X and Z and Z.s
awk '{print $1}' perf > id.dat.1 # animals with phenotypes
awk '{print $1}' perf > id.dat.2 # animals with phenotypes
awk '{print $2}' perf > HYS1 # HYS1
awk '{print $3}' perf > HYS2 # HYS2
awk '{print $4}' perf > y1 # FAT1 phenotypes
awk '{print $5}' perf > y2 # FAT2 phenotypes

# vectors for levels of each fixed effect
awk '$1!="."{print $1}' HYS1 | sort -u > HYS1.eff
awk '$1!="."{print $1}' HYS2 | sort -u > HYS2.eff

# vector of animals in the pedigree
awk '{print $1}' ped_stk > id.eff

# vector of unique animals in the performance file
awk '$1!="."{print $1}' id.dat.1 | sort -u > perf_id.eff.1
awk '$1!="."{print $1}' id.dat.2 | sort -u > perf_id.eff.2

# create X 
cgen_z -d HYS1 -e HYS1.eff -r y1 -o X1
cgen_z -d HYS2 -e HYS2.eff -r y2 -o X2

# create Z 
cgen_z -d id.dat.1 -e id.eff -r y1 -o Z1
cgen_z -d id.dat.2 -e id.eff -r y2 -o Z2

cnewr  -S -R resid -r R0 y1 y2
cnewr  -S -R genet -r G0 y1 y2

# create LHS matrices
cmult -t -a X1 -b X1 -R resid11 -c X1RX1
cmult -t -a X1 -b X2 -R resid12 -c X1RX2
cmult -t -a X2 -b X1 -R resid12 -c X2RX1
cmult -t -a X2 -b X2 -R resid22 -c X2RX2

cmult -t -a X1 -b Z1 -R resid11 -c X1RZ1
cmult -t -a X1 -b Z2 -R resid12 -c X1RZ2
cmult -t -a X2 -b Z1 -R resid12 -c X2RZ1
cmult -t -a X2 -b Z2 -R resid22 -c X2RZ2

cmult -t -a Z1 -b Z1 -R resid11 -c Z1RZ1
cmult -t -a Z1 -b Z2 -R resid12 -c Z1RZ2
cmult -t -a Z2 -b Z1 -R resid12 -c Z2RZ1
cmult -t -a Z2 -b Z2 -R resid22 -c Z2RZ2

# create RHS vectors
cmult -t -a X1 -b y1 -R resid11 -c X1Ry1
cmult -t -a X2 -b y1 -R resid12 -c X2Ry1
cmult -t -a X1 -b y2 -R resid12 -c X1Ry2
cmult -t -a X2 -b y2 -R resid22 -c X2Ry2

cmult -t -a Z1 -b y1 -R resid11 -c Z1Ry1
cmult -t -a Z2 -b y1 -R resid12 -c Z2Ry1
cmult -t -a Z1 -b y2 -R resid12 -c Z1Ry2
cmult -t -a Z2 -b y2 -R resid22 -c Z2Ry2

cadd -a X1Ry1 -b X1Ry2 -c rhs.0 #HYS effects FAT1
cadd -a X2Ry1 -b X2Ry2 -c rhs.1 #HYS effects FAT2

cadd -a Z1Ry1 -b Z1Ry2 -c rhs.2 #BV FAT1
cadd -a Z2Ry1 -b Z2Ry2 -c rhs.3 #BV FAT2


# set up LHS
echo "MAP
X1RX1   X1RX2   X1RZ1          X1RZ2
sym     X2RX2   X2RZ1          X2RZ2
sym     sym     Z1RZ1+Ainv*$g11 Z2RZ1+Ainv*$g12
sym     sym     sym            Z2RZ2+Ainv*$g22" > lhsmap

# set up RHS
echo "MAP
rhs.0
rhs.1
rhs.2
rhs.3" > rhsmap

# solve!
pcg -A lhsmap -b rhsmap -o sol -n 100 -N

# generate results files
mkdir Results
echo "Effect Solution" > Results/FixedEffectsFAT1
paste -d " " <(cat Sex.eff) sol.rhs.0 >> Results/FixedEffectsFAT1 
echo "Effect Solution" > Results/FixedEffectsFAT2
paste -d " " <(cat Sex.eff) sol.rhs.1 >> Results/FixedEffectsFAT2
echo "Animal Solution" > Results/AnimalEffectsFAT1
paste -d " " id.eff sol.rhs.2 >> Results/AnimalEffectsFAT1
echo "Animal Solution" > Results/AnimalEffectsFAT2
paste -d " " id.eff sol.rhs.3 >> Results/AnimalEffectsFAT2

# y-deviations
    cmult -a X1 -b sol.rhs.0 -c X1sol.rhs.0 # Xb (class/ cg)
    cmult -a X2 -b sol.rhs.1 -c X2sol.rhs.1 # Xb (class/ cg)
    cadd -a y1 -b X1sol.rhs.0 -r -1 -c y1_X1sol.0 # y1 - Xb
    cadd -a y2 -b X2sol.rhs.1 -r -1 -c y2_X2sol.1 # y2 - Xb

# YD
# YD = inv(Z'RZ)* Z'R(y - Xb) <- only anim with phenos

    cgen_z -d id.dat.1 -e id.dat.1 -r y1 -o Z1.s
    cgen_z -d id.dat.2 -e id.dat.2 -r y2 -o Z2.s

    cmult -t -a Z1.s -b Z1.s -R resid11 -c Z1RZ1.s
    cmult -t -a Z2.s -b Z1.s -R resid12 -c Z2RZ1.s
    cmult -t -a Z2.s -b Z2.s -R resid22 -c Z2RZ2.s

    cmult -t -a Z1.s -b y1_X1sol.0 -R resid11 -c Z1Ry1_adj # Z1'R(y1-dev)
    cmult -t -a Z2.s -b y1_X1sol.0 -R resid12 -c Z2Ry1_adj # Z2'R(y1-dev)
    cmult -t -a Z1.s -b y2_X2sol.1 -R resid12 -c Z1Ry2_adj # Z1'R(y2-dev)
    cmult -t -a Z2.s -b y2_X2sol.1 -R resid22 -c Z2Ry2_adj # Z2'R(y2-dev)

cadd -a Z1Ry1_adj -b Z1Ry2_adj -c Z1Ry_adj # rhs 1
cadd -a Z2Ry1_adj -b Z2Ry2_adj -c Z2Ry_adj # rhs 2

# set up LHS
echo "MAP
Z1RZ1.s Z2RZ1.s
sym   Z2RZ2.s" > lhsmap2

# set up RHS
echo "MAP
Z1Ry_adj
Z2Ry_adj" > rhsmap2

# solve
pcg -A lhsmap2 -b rhsmap2 -o YD -n 100 -N

echo "Animal YDSolution" > Results/YD_FAT1
paste -d " " id.dat.1 YD.Z1Ry_adj >> Results/YD_FAT1
echo "Animal YDSolution" > Results/YD_FAT2
paste -d " " id.dat.2 YD.Z2Ry_adj >> Results/YD_FAT2


# DYD
# sum_of W2prog*alpha_prog*(2YD-mate_bv) all divided by the sum_of W2prog*alpha_prog [eq. 5.13 page 91]

# where W2prog = (Z'RinvZ + Ginv*alpha_anim)inv*(Z-RinvZ) (page 104, where alpha_anim=2 for all animals)
# where alpha_anim= 2*alpha_par (assume no progeny I think? as alpha_anim=2*alpha_par + 0.5*alpha_prog on bottom of page 88) 
# where alpha_par= 1, 2/3 or 1/2 if both, one or neither parent known (same as "u" from single trait)
# where alpha_prog=1 if mate is known or 2/3 if unknown




# Anim, Sire, Dam, Inbreed
join -a1 -1 1 -2 1 <(sort ped_stk) inbreed > animInfo

# Anim, Sire, Dam, u
join -a1 -1 2 -2 1 -e "0" -o 1.1,1.2,1.3,1.4,2.4 <(sort -k2 animInfo) animInfo | sort -k3 \
| join -a1 -1 3 -2 1 -o 1.1,1.2,1.3,1.4,1.5,2.4 -e "0" - animInfo | awk '{F=($5+$6)/4; 
        if($2=="." && $3=="."){numParents=0;dinv=1.}
        else if($2!="." && $3!="."){numParents=2;dinv=1./(0.5-F)}
        else{numParents=1;dinv=1./(0.75-F)};
        print $1,$2,$3,0.5*dinv}' | sort > info_u # gives "u" from single-trait or alphapar (bottom of page 88)

#Anim, Sire, Dam, u or alphapar, alphaprog, alphaanim(assume no progeny?)
awk '{if($2=="."){prog=".";anim="."}else if($3!="."){prog=1;anim=2*$4}else{prog=(2/3);anim=2*$4};print $0,prog, anim}' info_u > animInfo2
join -o 2.5 id.dat.1 animInfo2 > alpprog1
join -o 2.5 id.dat.2 animInfo2 > alpprog2
cat alpprog1 alpprog2 > alpprog

awk '{if($2=="."){prog=".";anim="."}else if($3!="."){prog=1;anim=2*$4}else{prog=(2/3);anim=2*$4};
print $1, anim}' info_u | join -o 2.2 id.dat.1 - > alpanim.temp

awk -v nnz=$( wc -l alpanim.temp | awk '{print $1}') 'BEGIN{print "DIAGONAL",nnz,nnz,nnz}{print $0}' alpanim.temp > alpanim.diag
awk -v nnz=$( wc -l alpprog | awk '{print $1}') 'BEGIN{print "DIAGONAL",nnz,nnz,nnz}{print $0}' alpprog > alpprog.diag

cmult -a genet11 -b alpanim.diag -c alpG11
cmult -a genet12 -b alpanim.diag -c alpG12
cmult -a genet22 -b alpanim.diag -c alpG22

cadd -a Z1RZ1.s -b alpG11 -c W2_11
cadd -a Z2RZ1.s -b alpG12 -c W2_12
cadd -a Z2RZ2.s -b alpG22 -c W2_22

cvcat W2_11 W2_12 temp1
cvcat W2_12 W2_22 temp2
chcat temp1 temp2 temp3
invert -i temp3 -o temp4

cvcat Z1RZ1.s Z2RZ1.s ztemp1
cvcat Z2RZ1.s Z2RZ2.s ztemp2
chcat ztemp1 ztemp2 ztemp3
cmult -a temp4 -b ztemp3 -c W2temp


# get (2YD - mate bv) <- adjYD
join -a1 -1 3 -2 1 -e "0" -o 1.1,2.2 <(sort -k3 animInfo) <(awk 'NR>1{print $0}' Results/AnimalEffectsFAT1 | sort ) \
| sort | join -a1 <(awk 'NR>1{print}' Results/YD_FAT1) - | awk '{print $2*2-$3}' > adjYD_y1
awk -v nnz=$( wc -l adjYD_y1 | awk '{print $1}') 'BEGIN{print "DIAGONAL",nnz,nnz,nnz}{print $0}' adjYD_y1 > adjYD_y1.diag

join -a1 -1 3 -2 1 -e "0" -o 1.1,2.2 <(sort -k3 animInfo) <(awk 'NR>1{print $0}' Results/AnimalEffectsFAT2 | sort ) \
| sort | join -a1 <(awk 'NR>1{print}' Results/YD_FAT2) - | awk '{print $2*2-$3}' > adjYD_y2
awk -v nnz=$( wc -l adjYD_y2 | awk '{print $1}') 'BEGIN{print "DIAGONAL",nnz,nnz,nnz}{print $0}' adjYD_y2 > adjYD_y2.diag

cat adjYD_y1 adjYD_y2 > adjYD 
awk -v nnz=$( wc -l adjYD | awk '{print $1}') 'BEGIN{print "DIAGONAL",nnz,nnz,nnz}{print $0}' adjYD > adjYD.diag

# numerator and denominator for each progeny
# numer = W2 x alphaprog x (2YD - mate bv)
# denom = W2 x alphaprog

cmult -a alpprog.diag -b adjYD.diag -c temp
cmult -a W2temp -b temp -c numer


cmult -a W2temp -b alpprog.diag -c denom

# incidence matrices matching sires to progeny
join -a1 -o 2.2 id.dat.1 animInfo > sires_y1.temp
join -a1 -o 2.2 id.dat.2 animInfo > sires_y2.temp
awk '$2!="."{print}' sires_y1.temp | sort -u > sires_y1
awk '$2!="."{print}' sires_y2.temp | sort -u > sires_y2
cgen_z -d sires_y1.temp -e sires_y1 -r id.dat.1 -o sire_y1.temp
cgen_z -d sires_y2.temp -e sires_y2 -r id.dat.2 -o sire_y2.temp

cvcat sire_y1.temp sire_y2.temp sire_Z

# DYD
    cmult -t -a sire_Z -b numer -c sire_num                                     # numerator for each sire
    cmult -t -a sire_Z -b denom -c sire_den                                     # denominator for each sire
        


